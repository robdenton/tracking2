// Prisma schema for Marketing Activity Impact
// Uses SQLite locally; PostgreSQL for production on Vercel.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Activity {
  id                         String  @id @default(uuid())
  activityType               String  @map("activity_type")
  channel                    String
  partnerName                String  @map("partner_name")
  date                       String  // YYYY-MM-DD
  status                     String  @default("live") // live, booked, canceled
  costUsd                    Float?  @map("cost_usd")
  deterministicClicks        Int?    @map("deterministic_clicks")
  actualClicks               Int?    @map("actual_clicks")
  deterministicTrackedSignups Int?   @map("deterministic_tracked_signups")
  notes                      String?
  metadata                   String? @map("metadata") // JSON: channel-specific bet metrics
  contentUrl                 String? @map("content_url") // URL to the actual content (e.g. YouTube video)
  channelUrl                 String? @map("channel_url") // URL to the partner's channel

  contentViews               ContentView[]
  linkedInEngagements        LinkedInEngagement[]
  uplift                     ActivityUplift?

  @@map("activities")
}

model ActivityUplift {
  activityId                       String   @id @map("activity_id")
  computedAt                       DateTime @default(now()) @map("computed_at")

  // Baseline
  baselineWindowStart              String   @map("baseline_window_start")
  baselineWindowEnd                String   @map("baseline_window_end")
  baselineAvg                      Float    @map("baseline_avg")

  // Raw uplift (before proportional attribution)
  rawIncrementalSignups            Float    @map("raw_incremental_signups")
  rawIncrementalActivations        Float    @map("raw_incremental_activations")

  // Attributed uplift (after click-share splitting — the canonical figures)
  attributedIncrementalSignups     Float    @map("attributed_incremental_signups")
  attributedIncrementalActivations Float    @map("attributed_incremental_activations")

  // Attribution metadata
  clicksUsed                       Int?     @map("clicks_used")
  clicksSource                     String?  @map("clicks_source") // "actual" | "deterministic" | "estimated"

  // Confidence
  confidence                       String
  confidenceExplanation            String   @map("confidence_explanation")

  // JSON blobs for detail-page display
  dailySharesJson                  String?  @map("daily_shares_json") // DailyAttributionShare[]
  dailyDataJson                    String?  @map("daily_data_json")   // DayDataPoint[]

  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@map("activity_uplifts")
}

model DailyMetric {
  date        String  // YYYY-MM-DD
  channel     String
  signups     Int
  activations Int

  @@id([date, channel])
  @@map("daily_metrics")
}

model ContentView {
  activityId  String  @map("activity_id")
  date        String  // YYYY-MM-DD
  viewCount   Int     @map("view_count")
  activity    Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@id([activityId, date])
  @@map("content_views")
}

model LinkedInEngagement {
  activityId  String    @map("activity_id")
  date        String    // YYYY-MM-DD (tracking date)
  postDate    String?   @map("post_date") // When post was published
  likes       Int?
  comments    Int?
  reposts     Int?
  views       Int?      // Post impressions if visible
  activity    Activity  @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@id([activityId, date])
  @@map("linkedin_engagements")
}

// Imported YouTube videos that have been accepted for tracking
model ImportedYouTubeVideo {
  id              String   @id @default(uuid())
  videoId         String   @unique  // YouTube video ID (e.g., dQw4w9WgXcQ)
  title           String
  channelTitle    String   @map("channel_title")
  channelId       String   @map("channel_id")
  publishedAt     String   // YYYY-MM-DD when video was published
  url             String   // Full YouTube URL
  thumbnailUrl    String?  @map("thumbnail_url")

  importedDate    String   // YYYY-MM-DD when imported into system
  status          String   @default("active") // active, archived

  // Optional: link to Activity if this becomes a paid sponsorship
  relatedActivityId String?  @map("related_activity_id")

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  importedVideoViews ImportedVideoView[]

  @@map("imported_youtube_videos")
}

// Time-series view tracking for imported videos (follows ContentView pattern)
model ImportedVideoView {
  videoId    String  @map("video_id")
  date       String  // YYYY-MM-DD
  viewCount  Int     @map("view_count")
  video      ImportedYouTubeVideo @relation(fields: [videoId], references: [id], onDelete: Cascade)

  @@id([videoId, date])
  @@map("imported_video_views")
}

// Search results waiting for user review (accept/reject)
model YouTubeSearchResult {
  id              String   @id @default(uuid())
  videoId         String   @map("video_id")
  title           String
  channelTitle    String   @map("channel_title")
  channelId       String   @map("channel_id")
  publishedAt     String   // YYYY-MM-DD
  url             String
  thumbnailUrl    String?  @map("thumbnail_url")
  description     String?  // Video description snippet

  searchQuery     String   @map("search_query") // e.g., "granola ai"
  searchDate      String   @map("search_date")  // YYYY-MM-DD when found
  status          String   @default("pending")  // pending, accepted, rejected

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([videoId, searchQuery]) // Prevent duplicate search results
  @@map("youtube_search_results")
}

// LinkedIn company content analysis
model LinkedInCompany {
  id          String   @id @default(uuid())
  slug        String   @unique // e.g. "linearapp"
  name        String?  // e.g. "Linear"
  linkedinUrl String   @map("linkedin_url")
  scrapedAt   DateTime @map("scraped_at")

  posts LinkedInCompanyPost[]

  @@map("linkedin_companies")
}

model LinkedInCompanyPost {
  id                String  @id @default(uuid())
  companyId         String  @map("company_id")
  postText          String  @map("post_text")
  postDate          String? @map("post_date") // YYYY-MM-DD
  postUrl           String? @map("post_url")
  likes             Int?
  comments          Int?
  reposts           Int?
  views             Int?
  category          String?
  categoryReasoning String? @map("category_reasoning")

  company LinkedInCompany @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@map("linkedin_company_posts")
}

// Pipeline execution log — records each cron job run
model CronExecution {
  id            String    @id @default(uuid())
  taskName      String    @map("task_name")   // "sync-sheets", "track-youtube", etc.
  startedAt     DateTime  @map("started_at")
  completedAt   DateTime? @map("completed_at")
  status        String    // "running", "success", "error"
  resultJson    String?   @map("result_json") // JSON blob of task result counts
  errorMessage  String?   @map("error_message")

  @@index([taskName, startedAt])
  @@map("cron_executions")
}

// NextAuth.js authentication models
model User {
  id            String    @id @default(uuid())
  name          String?
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  accounts Account[]
  sessions Session[]

  @@map("users")
}

model Account {
  id                String  @id @default(uuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
